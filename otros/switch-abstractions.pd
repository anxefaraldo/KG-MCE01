#N canvas 827 239 527 327 12;
#X obj 204 56 r number-of-grains;
#X floatatom 204 87 5 0 0 0 - - - 12;
#X obj 109 331 throw~ grain;
#X obj 109 294 *~;
#X obj 159 233 line~;
#N canvas 0 22 450 300 mi-granulador 0;
#X obj 135 160 outlet;
#X restore 29 233 pd mi-granulador;
#X msg 159 204 \$1 100;
#X obj 299 294 switch~;
#X obj 204 150 tgl 25 0 empty empty empty 17 7 0 10 #191919 #e1e1e1 #e1e1e1 0 1;
#X obj 237 233 delay 110;
#X text 375 173 el objeto [switch~] activa/desactiva la computación de audio para cada subpatch. De este modo \, podemos optimizar el funcionamiento del programa \, ya que las voces que no necesitemos dejan de computar audio. En el ejemplo \, separamos el on (1) del off (0) \, ya que cuando activamos la voz lo primero que queremos hacer es activar la computación de audio \, pero cuando desactivamos la voz \, queremos que antes de parar la computación \, el objeto [line~] realice su recorrido completo hasta cero \, para evitar cualquier click indeseado. Por esa razon \, retrasamos la instrucción del switch off 110 ms con [delay 110], f 41;
#X obj 237 204 sel 0, f 13;
#X msg 238 262 0;
#X obj 204 117 <= \$1;
#X text 257 93 produce un boolean: 1 si el input es menor o igual a \$1 \, 0 si es mayor. De esa manera \, si pensamos que \$1 representa el número de instancia en una abtracción clonada \, m desactivaríamos todas las instancias mayores al número indicado.;
#X connect 0 0 1 0;
#X connect 1 0 13 0;
#X connect 3 0 2 0;
#X connect 4 0 3 1;
#X connect 5 0 3 0;
#X connect 6 0 4 0;
#X connect 8 0 6 0;
#X connect 8 0 11 0;
#X connect 9 0 12 0;
#X connect 11 0 9 0;
#X connect 11 1 7 0;
#X connect 12 0 7 0;
#X connect 13 0 8 0;
